let wasm;

const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* @param {Uint8Array} d
* @param {any} encoding
* @param {any} type_narrowing
* @returns {Query}
*/
function parse_text(d, encoding, type_narrowing) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(d, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.parse_text(retptr, ptr0, len0, addHeapObject(encoding), addHeapObject(type_narrowing));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return Query$1.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @returns {WasmWriter}
*/
function write_text() {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.write_text(retptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return WasmWriter.__wrap(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
* Holds the parsed data for a short period of time, allowing a user to extract all or a subset of the
* parsed document
*/
let Query$1 = class Query {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Query.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_query_free(ptr);
    }
    /**
    * Convert the entire document into an object
    * @returns {any}
    */
    root() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.query_root(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Convert the entire document into a JSON string
    * @param {boolean} pretty
    * @param {string} key_mode
    * @returns {any}
    */
    json(pretty, key_mode) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(key_mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.query_json(retptr, this.__wbg_ptr, pretty, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return the object, array, or value pointed at by the query. Uses a format similar to JSON pointer:
    *
    * ```ignore
    * /player
    * /countries/ENG/prestige
    * ```
    * @param {string} query
    * @returns {any}
    */
    at(query) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(query, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.query_at(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
};
/**
*/
class WasmWriter {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmWriter.prototype);
        obj.__wbg_ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmwriter_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    inner() {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_inner(retptr, ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    */
    write_object_start() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_object_start(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    */
    start_mixed_mode() {
        wasm.wasmwriter_start_mixed_mode(this.__wbg_ptr);
    }
    /**
    */
    write_array_start() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_array_start(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    */
    write_end() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_end(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {boolean} data
    */
    write_bool(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_bool(retptr, this.__wbg_ptr, data);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} data
    */
    write_operator(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.wasmwriter_write_operator(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} data
    */
    write_unquoted(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.wasmwriter_write_unquoted(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} data
    */
    write_quoted(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.wasmwriter_write_quoted(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} data
    */
    write_integer(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_integer(retptr, this.__wbg_ptr, data);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {bigint} data
    */
    write_u64(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_u64(retptr, this.__wbg_ptr, data);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} data
    */
    write_f32(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_f32(retptr, this.__wbg_ptr, data);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} data
    */
    write_f64(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_f64(retptr, this.__wbg_ptr, data);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} data
    */
    write_header(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.wasmwriter_write_header(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Date} data
    * @param {boolean} hour
    */
    write_date(data, hour) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.wasmwriter_write_date(retptr, this.__wbg_ptr, addHeapObject(data), hour);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_number_new = function(arg0) {
        const ret = arg0;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_af531cfef26eddd8 = function() {
        const ret = new Object();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_b1be4a78026c2347 = function(arg0, arg1, arg2) {
        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = getObject(arg1);
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len1;
        getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    };
    imports.wbg.__wbg_newwithlength_045c9df8a7cc3543 = function(arg0) {
        const ret = new Array(arg0 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_0ac78a2bc07da03c = function(arg0, arg1, arg2) {
        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
    };
    imports.wbg.__wbg_getUTCDate_6c05223a082fddd5 = function(arg0) {
        const ret = getObject(arg0).getUTCDate();
        return ret;
    };
    imports.wbg.__wbg_getUTCFullYear_4dc684843942793f = function(arg0) {
        const ret = getObject(arg0).getUTCFullYear();
        return ret;
    };
    imports.wbg.__wbg_getUTCHours_c27625b7db27bb6d = function(arg0) {
        const ret = getObject(arg0).getUTCHours();
        return ret;
    };
    imports.wbg.__wbg_getUTCMonth_86bf1b14c7bef4c1 = function(arg0) {
        const ret = getObject(arg0).getUTCMonth();
        return ret;
    };
    imports.wbg.__wbg_new_a49511604c14761d = function(arg0) {
        const ret = new Date(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_setUTCDate_a160d54d44a71713 = function(arg0, arg1) {
        const ret = getObject(arg0).setUTCDate(arg1 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_setUTCHours_784732367e8ba74b = function(arg0, arg1) {
        const ret = getObject(arg0).setUTCHours(arg1 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_UTC_82fb8afa56c31a3e = function(arg0, arg1) {
        const ret = Date.UTC(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedInt32Memory0 = null;
    cachedUint8Memory0 = null;


    return wasm;
}

async function __wbg_init(input) {
    if (wasm !== undefined) return wasm;

    if (typeof input === 'undefined') {
        input = new URL('jomini_js_bg.wasm', "");
    }
    const imports = __wbg_get_imports();

    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
        input = fetch(input);
    }

    const { instance, module } = await __wbg_load(await input, imports);

    return __wbg_finalize_init(instance, module);
}

let wasmInit = undefined;
let initialized = undefined;
const encoder = new TextEncoder();
class Jomini {
    constructor() { }
    parseText(data, options, cb) {
        if (typeof data === "string") {
            var inp = encoder.encode(data);
            options = { ...options, ...{ encoding: "utf8" } };
        }
        else {
            var inp = data;
        }
        const innerQuery = parse_text(inp, options?.encoding ?? "utf8", options?.typeNarrowing ?? "all");
        const query = new Query(innerQuery);
        if (cb === undefined) {
            const val = query.root();
            innerQuery.free();
            return val;
        }
        else {
            const val = cb(query);
            innerQuery.free();
            return val;
        }
    }
    write(cb) {
        let inner = write_text();
        let writer = new Writer(inner);
        cb(writer);
        return inner.inner();
    }
    /**
     * Initializes a jomini parser. There is a one time global setup fee (sub 30ms), but subsequent
     * requests to initialize will be instantaneous, so it's not imperative to reuse the same parser.
     */
    static initialize = async (options) => {
        if (initialized === undefined) {
            //@ts-ignore
            const loadModule = options?.wasm ?? wasmInit();
            initialized = __wbg_init(loadModule).then(() => void 0);
        }
        await initialized;
        return new Jomini();
    };
    /**
     * Resets initialization so that one can initialize the module again. Only
     * intended for tests.
     */
    static resetModule = () => {
        initialized = undefined;
    };
}
class Query {
    query;
    constructor(query) {
        this.query = query;
    }
    /** Convert the entire document into an object */
    root() {
        return this.query.root();
    }
    /**
     * Narrow down the document to just the specified property
     *
     * @param pointer the JSON pointer-esque string to the desired value
     * @returns object, array, or value identified by the query
     */
    at(pointer) {
        return this.query.at(pointer);
    }
    /** Convert the entire document into a JSON string */
    json(options) {
        return this.query.json(options?.pretty ?? false, options?.duplicateKeyMode ?? "group");
    }
}
/**
 * A text writer that accumulates commands written to an internal buffer
 */
class Writer {
    writer;
    constructor(writer) {
        this.writer = writer;
    }
    /**
     * Write out the start of an object
     */
    write_object_start() {
        this.writer.write_object_start();
    }
    /**
     * Write out the start of a hidden object
     */
    start_mixed_mode() {
        this.writer.start_mixed_mode();
    }
    /**
     * Write out the start of an array
     */
    write_array_start() {
        this.writer.write_array_start();
    }
    /**
     * End the outermost object or array
     */
    write_end() {
        this.writer.write_end();
    }
    /**
     * Write out a yes or no
     * @param data boolean to be written
     */
    write_bool(data) {
        this.writer.write_bool(data);
    }
    /**
     * Write an operator. Writing an equal operator is optional whenever
     * an object is being written.
     *
     * If an array was being written, the operator will switch to writing
     * an object
     * @param data operator to write out
     */
    write_operator(data) {
        this.writer.write_operator(data);
    }
    /**
     * Write unquoted data. Most, if not all object keys should be unquoted.
     * @param data unquoted data to write
     */
    write_unquoted(data) {
        if (typeof data === "string") {
            this.writer.write_unquoted(encoder.encode(data));
        }
        else {
            this.writer.write_unquoted(data);
        }
    }
    /**
     * Write a field to be encapsulated in quotes. Unlike the unquoted variant,
     * this method will inspect the data to ensure everything is properly
     * escaped, like quotes and escape characters. And will trim trailing
     * newlines. Strings that are passed in are assumed to be UTF-8, so if
     * you're wanting to write out EU4 data you'll want to first convert the
     * payload to a windows 1252 byte array.
     * @param data payload to be quoted
     */
    write_quoted(data) {
        if (typeof data === "string") {
            this.writer.write_quoted(encoder.encode(data));
        }
        else {
            this.writer.write_quoted(data);
        }
    }
    /**
     * Write a header object like (rgb, hsv, LIST, etc). One will need to start an array
     * or object after calling this method
     * @param data the header
     */
    write_header(data) {
        if (typeof data === "string") {
            this.writer.write_header(encoder.encode(data));
        }
        else {
            this.writer.write_header(data);
        }
    }
    /**
     * Write a signed number
     * @param data signed payload
     */
    write_integer(data) {
        this.writer.write_integer(data);
    }
    /**
     * Write an unsigned big number
     * @param data big number
     */
    write_u64(data) {
        this.writer.write_u64(data);
    }
    /**
     * Write a 32 bit floating point number
     * @param data 32 bit floating point
     */
    write_f32(data) {
        this.writer.write_f32(data);
    }
    /**
     * Write a 64 bit floating point number
     * @param data 64 bit floating point
     */
    write_f64(data) {
        this.writer.write_f64(data);
    }
    /**
     * Write a date
     * @param date date
     */
    write_date(date, options) {
        this.writer.write_date(date, options?.hour ?? false);
    }
}

/**
 * Mutates a container by drilling down to a property and ensuring it is an array.
 * This function is useful when dealing with documents where a single occurence of
 * a field can be mistaken for a scalar value instead of an array. This function
 * ensures that all properties that need to be arrays are arrays.
 *
 * @param obj The array or object to mutate
 * @param path The path to a field to ensure it is an array
 */
function toArray(obj, path) {
    const splits = path.split(".");
    if (splits.length == 1) {
        // If the object has the specified field and it isn't already an
        // array. Make it a one element array
        if (!Array.isArray(obj[path]) &&
            Object.prototype.hasOwnProperty.call(obj, path)) {
            obj[path] = [obj[path]];
        }
    }
    else if (Object.prototype.hasOwnProperty.call(obj, splits[0])) {
        // If the property is an array, make sure to apply this function to
        // all of the subsequent items
        if (Array.isArray(obj[splits[0]])) {
            const arr = obj[splits[0]];
            for (let i = 0; i < arr.length; i++) {
                if (typeof arr[i] === "object") {
                    toArray(arr[i], path.substring(splits[0].length + 1));
                }
            }
        }
        else if (typeof obj[splits[0]] === "object") {
            toArray(obj[splits[0]], path.substring(splits[0].length + 1));
        }
    }
}

export { Jomini, Query, Writer, toArray };
